Paso 1: Crear el nuevo archivo con la estructura básica
tsxCopy// src/components/cart/NewProductDetailModal.tsx
import { useState, useEffect } from 'react';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import { ChevronDown, ChevronUp, Minus, Plus, X, Share, Bookmark, Check } from 'lucide-react';

// Interfaces (mantener las mismas que en ProductDetailModal.tsx)
interface OptionItem {
  id: number;
  name: string;
  price_addition: number;
  available: boolean;
  image_url?: string;
}

interface ProductOption {
  id: number;
  name: string;
  required: boolean;
  multiple: boolean;
  max_selections?: number;
  items: OptionItem[];
}

interface Product {
  id: number;
  name: string;
  description?: string;
  price: number;
  image_url?: string;
  options?: ProductOption[];
}

interface SelectedOption {
  optionId: number;
  optionName: string;
  items: {
    id: number;
    name: string;
    price_addition: number;
  }[];
}

interface ProductDetailModalProps {
  product: Product;
  isOpen: boolean;
  onClose: () => void;
  onAddToCart: (product: Product, quantity: number, selectedOptions: SelectedOption[]) => void;
}

export const NewProductDetailModal: React.FC<ProductDetailModalProps> = ({
  product,
  isOpen,
  onClose,
  onAddToCart
}) => {
  // Estados (mantener los mismos que en ProductDetailModal)
  const [quantity, setQuantity] = useState(1);
  const [selectedOptions, setSelectedOptions] = useState<SelectedOption[]>([]);
  const [validationError, setValidationError] = useState<string | null>(null);
  const [expandedOptions, setExpandedOptions] = useState<Record<number, boolean>>({});

  // Inicializar las opciones expandidas al abrir el modal
  useEffect(() => {
    if (isOpen && product.options) {
      const initialExpandedState: Record<number, boolean> = {};
      product.options.forEach(option => {
        initialExpandedState[option.id] = true; // Por defecto todas expandidas
      });
      setExpandedOptions(initialExpandedState);
    }
  }, [isOpen, product.options]);

  // Restablecer estados cuando se abre el modal
  useEffect(() => {
    if (isOpen) {
      setQuantity(1);
      setSelectedOptions([]);
      setValidationError(null);

      // Inicializar opciones
      if (product.options) {
        const initialOptions: SelectedOption[] = [];
        product.options.forEach(option => {
          initialOptions.push({
            optionId: option.id,
            optionName: option.name,
            items: []
          });
        });
        setSelectedOptions(initialOptions);
      }
    }
  }, [isOpen, product.id]);

  // No renderizamos nada si no está abierto
  if (!isOpen) return null;

  // Formateamos el precio para que se vea como en la imagen de referencia
  const formatPrice = (price: number) => {
    // Asegurémonos de que el precio sea un número
    const numericPrice = typeof price === 'number' ? price : 0;

    try {
      // Primero convertimos a string con el formato deseado
      return numericPrice.toLocaleString('es-CL', {
        style: 'currency',
        currency: 'CLP',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      }).replace('CLP', '$').replace('.', ',');
    } catch (error) {
      // Si algo falla, usamos una versión más simple
      return '$' + numericPrice.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
    }
  };

  // Calcular precio adicional basado en las opciones seleccionadas
  const calculateAdditionalPrice = () => {
    if (!product.options) return 0;

    let additionalPrice = 0;

    selectedOptions.forEach(selectedOption => {
      selectedOption.items.forEach(item => {
        additionalPrice += Number(item.price_addition) || 0;
      });
    });

    return additionalPrice;
  };

  // Precio adicional por opciones
  const additionalPrice = calculateAdditionalPrice();

  // Precio total basado en la cantidad
  const totalPrice = (product.price || 0) * quantity + additionalPrice * quantity;

  // Verificar si un ítem está seleccionado
  const isItemSelected = (optionId: number, itemId: number): boolean => {
    const option = selectedOptions.find(opt => opt.optionId === optionId);
    if (!option) return false;
    return option.items.some(item => item.id === itemId);
  };

  // Manejar selección de opción
  const handleOptionSelect = (option: ProductOption, item: OptionItem) => {
    setSelectedOptions(prev => {
      // Buscar la opción en el array de opciones seleccionadas
      const optionIndex = prev.findIndex(opt => opt.optionId === option.id);

      // Si la opción ya está seleccionada
      if (optionIndex >= 0) {
        const updatedOptions = [...prev];
        const itemIndex = updatedOptions[optionIndex].items.findIndex(it => it.id === item.id);

        // Si permite múltiples selecciones
        if (option.multiple) {
          // Si ya está seleccionado, quitar
          if (itemIndex >= 0) {
            updatedOptions[optionIndex].items = updatedOptions[optionIndex].items.filter(it => it.id !== item.id);
          }
          // Si no está seleccionado y no excede el máximo, añadir
          else if (!option.max_selections || updatedOptions[optionIndex].items.length < option.max_selections) {
            updatedOptions[optionIndex].items = [
              ...updatedOptions[optionIndex].items,
              { id: item.id, name: item.name, price_addition: item.price_addition }
            ];
          }
        }
        // Si solo permite una selección
        else {
          // Si ya está seleccionado, deseleccionar
          if (itemIndex >= 0) {
            updatedOptions[optionIndex].items = [];
          }
          // Si no está seleccionado, seleccionar solo este
          else {
            updatedOptions[optionIndex].items = [
              { id: item.id, name: item.name, price_addition: item.price_addition }
            ];
          }
        }

        return updatedOptions;
      }
      // Si la opción no está en el array, añadirla
      else {
        return [
          ...prev,
          {
            optionId: option.id,
            optionName: option.name,
            items: [{ id: item.id, name: item.name, price_addition: item.price_addition }]
          }
        ];
      }
    });

    // Limpiar error de validación cuando el usuario selecciona algo
    setValidationError(null);
  };

  // Alternar la expansión/colapso de una opción
  const toggleOption = (optionId: number) => {
    setExpandedOptions(prev => ({
      ...prev,
      [optionId]: !prev[optionId]
    }));
  };

  // Verificar si todas las opciones requeridas tienen selecciones
  const validateRequiredOptions = (): boolean => {
    if (!product.options) return true;

    const requiredOptions = product.options.filter(option => option.required);

    for (const option of requiredOptions) {
      const selectedOption = selectedOptions.find(opt => opt.optionId === option.id);
      if (!selectedOption || selectedOption.items.length === 0) {
        setValidationError(`Por favor selecciona una opción de "${option.name}"`);

        // Auto-expandir la opción con error
        setExpandedOptions(prev => ({
          ...prev,
          [option.id]: true
        }));

        return false;
      }
    }

    return true;
  };

  // Verificar si una opción tiene al menos un ítem seleccionado
  const hasSelectedItems = (optionId: number): boolean => {
    const option = selectedOptions.find(opt => opt.optionId === optionId);
    return !!option && option.items.length > 0;
  };

  // Manejar la adición al carrito
  const handleAddToCart = () => {
    // Validar opciones requeridas
    if (!validateRequiredOptions()) return;

    // Filtrar opciones que tienen al menos un ítem seleccionado
    const filledOptions = selectedOptions.filter(option => option.items.length > 0);

    onAddToCart({ ...product, quantity }, quantity, filledOptions);
    onClose();
  };

  // Manejar cambio de cantidad
  const handleQuantityChange = (increment: number) => {
    const newQuantity = quantity + increment;
    if (newQuantity >= 1) {
      setQuantity(newQuantity);
    }
  };

  return (
    <div className="fixed inset-0 z-50 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="max-w-md w-full bg-white rounded-lg overflow-hidden shadow-lg max-h-[90vh] overflow-y-auto">
        {/* Aquí irá el contenido del modal con el nuevo diseño */}
      </div>
    </div>
  );
}

export default NewProductDetailModal;
Paso 2: Implementar la cabecera y la imagen del producto
Ahora vamos a reemplazar el "Aquí irá el contenido del modal con el nuevo diseño" con la primera parte del diseño:
tsxCopy{/* Header con botones e imagen */}
<div className="relative h-60 bg-gray-100">
  <div className="absolute top-0 left-0 right-0 p-4 flex justify-between items-center z-10">
    <button 
      className="w-10 h-10 rounded-full bg-white flex items-center justify-center shadow"
      onClick={onClose}
    >
      <X size={24} />
    </button>
    <div className="flex space-x-2">
      <button className="w-10 h-10 rounded-full bg-white flex items-center justify-center shadow">
        <Share size={20} />
      </button>
      <button className="w-10 h-10 rounded-full bg-white flex items-center justify-center shadow">
        <Bookmark size={20} />
      </button>
    </div>
  </div>
  
  {product.image_url ? (
    <div className="w-full h-full relative">
      <Image
        src={product.image_url}
        alt={product.name}
        fill
        style={{ objectFit: 'cover' }}
      />
    </div>
  ) : (
    <div className="w-full h-full flex items-center justify-center bg-gray-200">
      <svg xmlns="http://www.w3.org/2000/svg" className="h-20 w-20 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
      </svg>
    </div>
  )}
</div>

{/* Información del producto */}
<div className="p-4">
  <div className="text-3xl font-bold text-gray-900">{formatPrice(product.price)}</div>
  <h1 className="text-3xl font-bold mt-2">{product.name}</h1>
  {product.description && (
    <p className="text-gray-600 mt-1">{product.description}</p>
  )}
</div>
Paso 3: Implementar las secciones de opciones
Ahora vamos a añadir las secciones de opciones después de la información del producto:
tsxCopy{/* Secciones de opciones */}
<div className="border-t border-gray-200">
  {product.options && product.options.map((option) => (
    <div key={option.id} className="border-b border-gray-200">
      <div 
        className="flex justify-between items-center p-4 cursor-pointer"
        onClick={() => toggleOption(option.id)}
      >
        <div className="flex items-center">
          <h2 className="text-xl font-bold">{option.name}</h2>
          {option.required && (
            <span className="ml-2 px-2 py-1 bg-gray-200 text-gray-700 text-sm rounded">
              Obligatorio
            </span>
          )}
        </div>
        <div className="flex items-center">
          {hasSelectedItems(option.id) && (
            <span className="bg-green-500 text-white px-3 py-1 rounded-full mr-2">
              Listo
            </span>
          )}
          {expandedOptions[option.id] ? <ChevronUp size={24} /> : <ChevronDown size={24} />}
        </div>
      </div>
      
      {expandedOptions[option.id] && (
        <div className="px-4 pb-4">
          {option.items.map(item => (
            <div 
              key={item.id}
              className="flex items-center justify-between py-3 border-b border-gray-100 last:border-0"
              onClick={() => item.available && handleOptionSelect(option, item)}
            >
              <div className="flex items-center">
                {item.image_url && (
                  <img 
                    src={item.image_url} 
                    alt={item.name}
                    className="w-12 h-12 rounded-md object-cover mr-3"
                  />
                )}
                <div>
                  <span className="text-lg">{item.name}</span>
                  {item.price_addition > 0 && (
                    <div className="text-gray-500">+ {formatPrice(item.price_addition)}</div>
                  )}
                </div>
              </div>
              
              {/* Radio button para selección única */}
              {!option.multiple && (
                <div 
                  className={`w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                    isItemSelected(option.id, item.id) ? 'border-green-500 bg-white' : 'border-gray-300'
                  } ${!item.available ? 'opacity-50' : ''}`}
                >
                  {isItemSelected(option.id, item.id) && (
                    <div className="w-4 h-4 rounded-full bg-black"></div>
                  )}
                </div>
              )}
              
              {/* Botón de añadir para selección múltiple */}
              {option.multiple && (
                <button 
                  className={`w-8 h-8 rounded-full bg-white border border-gray-300 flex items-center justify-center ${
                    !item.available ? 'opacity-50' : ''
                  }`}
                  disabled={!item.available}
                >
                  {isItemSelected(option.id, item.id) ? (
                    <Check size={20} className="text-green-500" />
                  ) : (
                    <Plus size={20} />
                  )}
                </button>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  ))}
</div>

{/* Mensaje de error de validación */}
{validationError && (
  <div className="mx-4 mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-600 text-sm flex items-center">
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </svg>
    {validationError}
  </div>
)}
Paso 4: Implementar la sección inferior con el contador y el botón de agregar
Finalmente, añadamos la sección inferior:
tsxCopy{/* Cantidad y botón Agregar */}
<div className="p-4 flex items-center justify-between border-t border-gray-200">
  <div className="flex items-center border border-gray-300 rounded-full overflow-hidden">
    <button 
      className="w-10 h-10 flex items-center justify-center"
      onClick={() => handleQuantityChange(-1)}
      disabled={quantity <= 1}
    >
      <Minus size={20} className={quantity <= 1 ? 'text-gray-300' : ''} />
    </button>
    <span className="w-10 text-center">{quantity}</span>
    <button 
      className="w-10 h-10 flex items-center justify-center"
      onClick={() => handleQuantityChange(1)}
    >
      <Plus size={20} />
    </button>
  </div>
  
  <button 
    className={`bg-green-500 text-white px-4 py-3 rounded-full flex items-center justify-center ${
      !validateRequiredOptions() ? 'opacity-70' : ''
    }`}
    onClick={handleAddToCart}
    disabled={!validateRequiredOptions()}
  >
    <span className="mr-2">Agregar</span>
    <span>{formatPrice(totalPrice)}</span>
  </button>
</div>
Paso 5: Ensamblando todo
Ahora que hemos implementado todas las partes, vamos a asegurarnos de que estén correctamente integradas. Puedes reemplazar el return existente en NewProductDetailModal con todo el código que hemos creado paso a paso.